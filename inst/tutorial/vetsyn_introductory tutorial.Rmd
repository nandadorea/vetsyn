VETSYN - introductory tutorial
========================================================

# Getting started with the package

Install and load the package:

```{r load.package}
##install.packages("devtools")
##library(devtools)
##dev_mode(on=T)
#install_github("vetsyn")

#library(vetsyn)
require(devtools)
load_all()

```

# Getting started with your data

## Raw data

This assumes the user has acces to some **data which contains events to be monitored**, and which comes in the format of a **flat table**. Observations do not need to be unique per row. 

You can work through this tutorial with the data provided as part of the package. 

```{r load.raw.data}
data(lab.daily)
head(lab.daily)

data(observed)
head(observed)

```

_lab.daily_ is an example of the type of flat file that the user is expected to have access to. It refers to laboratory submissions to a diagnostic laboratory (the actual country, laboratory, animal species and test names were removed due to privacy issues). The _SubmissionID_ identifies unique submissions, but each submission can have multiple performed tests, multiple herds and multiple animals, so multiple rows can have the have _SubmissionID_. Unique events are therefore defined as a unique submission (_SubmissionID_), in an unique date (_DateofSubmission_), classified into the same syndrome (_Syndrome_), and in either a unique animal (_AnimalID_), a unique herd (_HerdID_) or a unique sample (_MaterialID_), according to the syndromic surveillance operator's decision of which is relevant. 

The functions can handle any other type of syndromic data (not only laboratory submissions) provided that the format is similar: a column with dates, a column (or a combination of) providing unique identification of events, and a columns with the syndromic classification.

_observed_ is a dataset that represents the number of daily counts to each syndrome. The package goal is to make it possible to work from raw data already classified into syndromes (such as lab.daily), but users who may already have consolidated data to a format like _observed_ can also use the detection functions.

## SYNDROMIC - the central object of the package

The center of the package are objectes of the class _**syndromic**_. These objects are designed to contain all information extracted from the data and relevant for syndromic surveillance, from counts to alarms, in one single place. The dimensions of the object serve as a way to keep data validated.

_**syndromic**_ is a S4 class, which means the object is divided in slots that can be accessed using @:

*__@observed__ - _t x S dimensions_: Here the obrserved data are stored - the number of events for each syndrome in each time point. The _observed_ slot has as many columns as the number of syndromes to be monitored, and as many rows as time points. At present the package is only able to deal with daily data (so each time point is one day).  
*__@dates__ _t x 9 dimensions_: This slot stores the dates sequence. The rows are created as the data are evaluated, and the columns are pre-set in the package:
  *date:the column with the date in the format yyyy-mm-dd; 
  *mday: integer representing the day number within the month
  *month: the month, from 0 (January) to 12 (December)
  *year: the year in the format yyyy
  *yday: counts the day of the year continuoysly (from1 to 365 or 366)
  *week: the week of the month, from 1 to 52 (or 53)
  *dow: the day of the week, from 0 (Sunday) to 6 (Saturday)
  *weekday: a binary variables indicating whether the day is a weekday (1) or not (0). A variable for holidays was not included because holidays are country dependent. But the user can set up their own dates data.frame, as mentioned below.
*__@baseline__ - _t x S dimensions_: if outbreak signals are detected in the observed data, rendering those data unfit to serve as a baseline for detection of new outbreaks in the future, then "cleaned" data should be stored for the purpose of training the detection algorithms. This slot if the place to store such outbreak-free baseline (how to clean the data is discussed below). 
*__@alarms__ - _t x S x A dimensions_: once a detection algorithm has been applied to the data, the results are stored here. However, multiple algorithms for detection can be used, so @alarms is actually an array, where alarms for each day (rows), each syndrome (columns) and each detection algorithm (3rd dimension) are stored. Alarms can be bonary or integer, as discussed below.
*__@UCL__ - _t x S x A dimensions_: besides storing the alarm (whether there was detection or not), the user can also store the minimum number of events (_upper control limit_) that would have generated an alarm, per day and syndrome, for each algorithm (provided that a specific detection limit is given for each algorithm).
*__@LCL__ - _t x S x A dimensions_: when using algorithms that are able to detect DECREASES in the expected number of observations, besides storing the alarm (whether there was detection or not), the user can also store the maximim number of events (_lower control limit_) that would have generated an alarm, per day and syndrome, for each algorithm (provided that a specific detection limit is given for each algorithm).

It is expected that the construction of a _**syndromic object**_ starts when the user has only the flat table of data, which means that the only data available from the beginning are those that go into the slots _@observed_ and _@dates_. The user can have those data already formatted in a matrix and data-frame format, respectively, in which case they can use directly the function _syndromic()_.



```{r observed.to.syndromic}

my.syndromic <- syndromic(observed,min.date="03/01/2011",max.date="28/05/2013")
```

If the dates are left blank, the user can use the function
      **setDates <-**
to give a full, customized data-frame for the slots _@dates_. This will work as long as said data-frame has the exact same number of rows as the matrix provided for _@observed_.

However, the user can take maximum advantage of the package by using its functions to convert the raw (classified) data into a formatted matrix to go into _@observed_. For that, one would use the function *raw_to_syndromic()*. 

It requires that the user specifies which column in the raw data stores the dates (and the format of the dates); which column or columns (**id**) should be used to identify the unique cases (see below for examples when more than one column are needed); and where the syndromic classification can be found (**syndromes.var**).

```{r raw.to.syndromic}

  my.syndromic <- raw_to_syndromic (id=SubmissionID, 
                                    syndromes.var=Syndrome,
                                    dates.var=DateofSubmission, 
                                    date.format="%d/%m/%Y", 
                                    data=lab.daily)
```

The function counts the number of cases (ids) per syndrome, per day, and stores all in a syndromic object. In the process, any repeated cases (multiple ids with the same syndromic classification in the same day) are discarded. Also, the dates are counted as a complete sequence. If for instance an observation exists for day 2013-11-01, and the next observation is on date 2013-11-04, then 4 rows are created (days 1, 2, 3 and 4 of November) and days 2 and 3 are assigned a count of zero. 

Below you can see several other examples of how the *raw_to_syndromic()* function can be used.

Note that the user does not have to count _all_ nor _only_ the syndromes that appear int he data. If a set list of syndromes exist for your syndromic surveillance system, that can be provided as a list. Any syndromes in the list not found in the data will be assigned a count of zero for every day. Any syndromes appearing in the data which are not in the list will be ignored. This is important in order to prevent that data from different time periods end up generating a different set of syndromic groups. 


```{r raw.to.syndromic2}

####multiple ID columns
  my.syndromic <- raw_to_syndromic (id=list(HerdID,AnimalID), 
                                    syndromes.var=Syndrome,
                                    dates.var=DateofSubmission, 
                                    date.format="%d/%m/%Y", 
                                    sort=TRUE,
                                    data=lab.daily)
####specific syndromes
   my.syndromic <- raw_to_syndromic (id=SubmissionID, 
                                    syndromes.var=Syndrome,
                                    syndromes.name=c("GIT","Musculoskeletal"),
                                    dates.var=DateofSubmission, 
                                    date.format="%d/%m/%Y", 
                                    sort=TRUE,
                                    data=lab.daily)

####fix the dates
##start precisely at the beginning of the year
  my.syndromic <- raw_to_syndromic (id=SubmissionID, 
                                    syndromes.var=Syndrome,
                                    dates.var=DateofSubmission, 
                                    date.format="%d/%m/%Y", 
                                    min.date="01/01/2011", 
                                    max.date="01/01/2014",
                                    sort=TRUE,
                                    data=lab.daily)

####ignore weekends and add Saturday's counts to Friday, and Sunday's counts to Mondays
  my.syndromic <- raw_to_syndromic (id=SubmissionID, 
                                    syndromes.var=Syndrome,
                                    dates.var=DateofSubmission, 
                                    date.format="%d/%m/%Y", 
                                    max.date="01/01/2014",
                                    remove.dow=c(6,0),
                                    add.to=c(2,1),
                                    sort=TRUE,
                                    data=lab.daily)



##### this is the syndromic object we will work with for the rest of this tutorial
my.syndromic <- raw_to_syndromic (id=SubmissionID, 
                                    syndromes.var=Syndrome,
                                    dates.var=DateofSubmission, 
                                    date.format="%d/%m/%Y", 
                                    remove.dow=c(6,0),
                                    add.to=c(2,1),
                                    sort=TRUE,
                                    data=lab.daily)


```

You can explore the syndromic object using regular functions from R.

Note that when you simply type the object name into the console, the data are not printed (since it could be quite massive), but instead a summary of the object. To see the data in specific slots, you can use functions such as _head()_ and _tail()_, or subsetting.

```{r exploring.syndromic}

my.syndromic

dim(my.syndromic)
  dim(my.syndromic)[1] #rows = number of time points
  dim(my.syndromic)[2] #columns = number of syndromes monitored
  dim(my.syndromic)[3] #3rd dimension = number of detection algorithms used (more later)

head(my.syndromic@observed)
tail(my.syndromic@dates)

my.syndromic@observed[1:5,]
```

Note that in order to subset the whole syndromic object (not only specific slots) you can use subsetting in the following way: **(please nothe the use of comma(,) instead of a colon(:))**

```{r subsetting.syndromic}

my.syndromic.short <- my.syndromic[1,5]
  my.syndromic.short
  my.syndromic.short@observed
  my.syndromic.short@dates

```


Once all your observed data are into a syndromic object, you are ready to start the analyses.

# Retrospective analysis

The expected pathway to build syndromic surveillance is to start with a good "chunk" of data, say at least two years. That is, you would request a batch of data from your data provider. Once classified into syndromes, those data would be converted to a syndromic object all at once as we did in the previous section. The step of online data acquisition, where the syndromic object grows time point by time point comes later. For now, you should be concerned with retrospective evaluation of all the data you have. 


## Summary

To construct a summary of your data, as described in:

Fernanda C. DÃ³rea, Crawford W. Revie, Beverly J. McEwen, W. Bruce McNab, David Kelton, Javier Sanchez (2012) Retrospective time series analysis of veterinary laboratory data: Preparing a historical baseline for cluster detection in syndromic surveillance. Preventive Veterinary Medicine. DOI: 10.1016/j.prevetmed.2012.10.010.


from a syndromic object requires only the command:

```{r retro.summary}

####We removed weekends, so our cycles (years) are of 260 days only. 
####The default for the function is 365

      #retro_summary(my.syndromic, frequency=260)

```

In this tutorial the command has been commented out so that this function (which creates folders on your computer and takes a considerable amount of time) is only run if you really decide to do so. Then, do it manually. 

The command will create a folder within the current working directory (so make sure to check where that is beforehand using _getwd()_, and if needed change it using _setwd()_). Within this folder, it will save a html file with a number of summary statistics and regression models fit to your data, for a first quick assessment of how the data look like. A markdown version of the file will also be saved in the created directory. You can access that file to see directly all the R codes used to create such summaries, and change the regression models as necessary. 

Consult the help of the *retro_summary()* function to explore the options that can be adjusted.

The function is set to provide a great number of regression models, but some will not be appropriate for your data. Just take a look at all the outputs, they should help you deciding on an appropriate direction to take your analysis. Then, using as a start the R codes provided in the markdown file generated by the function, deepen your analysis as needed. 

The main goal is to identify a regression model that works well with the temporal effects found in your data (or possibly determine that a parametric model is not needed).


## Cleaning baseline

In the reference cited above, we also described a method to clean the baseline from outbreak signals and excessive noise. You can apply it to your data to create an _**outbreak-free baseline**_ using the  *clean_baseline* function. A non-parametric version is also available - *clean_baseline_perc()*.

The parametric version requires the user to provide a regression family and a regression formula (as should have been ientified in the previous step). The data in the slot _@observed_ are then used to fit a regression model based on that formula. Any observations above the confidence intrval set in the _limit_ argument are removed and substituted by the limit of such confidence interval. The remaining time-series in then saved into the slot _@baseline_. The results are plotted unless the user sets _plot=FALSE_. 

It is not uncommon that the different syndromes in the syndromic object will have different characteristics, and therefore demand varied models. Therefore, the user should apply *clean_baseline* listing out which specific syndromic groups are targetted. If not syndromic group is specified, the process will be appplied to all columns in the _@observed_.


```{r baseline}

#minimal set up
    ##will be applied to all syndromic groups 
    ##the default model is
    ##when a user does not specify, the default formula for regression is
          ##"dow+sin+cos+year+AR1+AR2+AR3+AR4+AR5+AR6+AR7"

my.syndromic2 <- clean_baseline(my.syndromic)

#a more realistic, still simple example
my.syndromic2 <- clean_baseline(my.syndromic, 
                                syndromes="Musculoskeletal", 
                                formula="dow+month+year",
                                plot=FALSE)


#for the data being used as an example in this tutorial:
  #(which contains no weekends, weeks have 5 days only)
my.syndromic <- clean_baseline(my.syndromic,
                               syndromes="Musculoskeletal",
                               formula="dow+sin+cos+year+AR1+AR2+AR3+AR4+AR5")

```

The non-parametric version works in a similar way, but percentiles are used instead of regression models. It will be used for all other syndromes in this example (regression models were applied to "Musculoskeletal" above).

```{r baseline_perc}

# change the percentile used for correction (default is 0.95)
my.syndromic2 <- clean_baseline_perc(my.syndromic, 
                  syndromes=2,
                  limit=0.90)

# change the number of time points included in the running window
  #default is 120
my.syndromic2 <- clean_baseline_perc(my.syndromic, 
                  run.window=90,
                  plot=FALSE)

#for the data being used as an example in this tutorial:
my.syndromic <- clean_baseline_perc(my.syndromic,
                                    syndromes=c(1,2,4,5))

```


# Testing prospective (prospective with batch data)

At this point you have observed data and a baseline to train outbreak-signal detection algorithms. The next step should be to implement detection.

## Holt Winters (data-driven, no pre-processing necessary)

If baseline slot totally empty, will fill it all with NA. Then only for the syndromes evaluated, it will pull from observed.

If alarms empty (for some or all dimensions needed), will fill with NA (so that only days actually evaluated will have a number, be it 0 or alarm). 

Multiple limits can be used and the alarms add. But if re-evaluating data, it resets to zero and then starts adding again.

Note how just saves to the same object - just processing one of the slots (but could save int a new one if wanted)

----> Explain the options

correct baseline (in this tutorial made with holt winters)

```{r holt_winters}

#holt_winters_synd (x,
#                    syndromes=NULL,
#                    evaluate.window=1,
#                    frequency=7,
#                    baseline.window=365,
#                    limit.sd=c(2.5,3,3.5),
#                    nahead=7,
#                    alpha=0.4,
#                    beta=0,
#                    gamma=0.15,
#                    seasonal="additive",
#                    correct.baseline=1,
#                    alarm.dim=1,
#                    UCL=TRUE
#                    )

my.syndromic <- holt_winters_synd(x=my.syndromic,
                             evaluate.window=30,
                             frequency=5,
                             baseline.window=260,
                             limit.sd=c(2.5,3,3.5), #default
                             nahead=5,
                             correct.baseline=2,
                             alarm.dim=1)


# my.syndromic <- holt_winters_synd(x=my.syndromic,
#                              evaluate.window=30,
#                              frequency=7,
#                              baseline.window=365,
#                              limit.sd=c(2.5,3,3.5), #default
#                              nahead=7,
#                              correct.baseline=2,
#                              alarm.dim=1)


```



```{r ewma}
# (x,
#                     syndromes=NULL,
#                     evaluate.window=1,
#                     baseline.window=365,
#                     lambda=0.2,
#                     limit.sd=c(2.5,3,3.5),
#                     guard.band=7,
#                     correct.baseline=FALSE,
#                     alarm.dim=2,
#                     UCL=TRUE,
#                     LCL=FALSE,
#                     pre.process=FALSE,
#                     diff.window=7,
#                     family="poisson",
#                     formula="dow+sin+cos+year+AR1+AR2+AR3+AR4+AR5+AR6+AR7"
#           )


my.syndromic <- ewma_synd(x=my.syndromic,
                          syndromes="Musculoskeletal",
                          evaluate.window=30,
                          baseline.window=260,
                          lambda=0.2,
                          limit.sd=c(2.5,3,3.5),
                          guard.band=5,
                          correct.baseline=FALSE,
                          alarm.dim=2,
                          UCL=2,
                          LCL=FALSE,                          
                          pre.process="glm",
                          family="poisson",
                          formula="dow+sin+cos+AR1+AR2+AR3+AR4+AR5",
                          period=260)


my.syndromic <- ewma_synd(x=my.syndromic,
                           syndromes= c(1,2,4,5),
                          evaluate.window=30,
                          baseline.window=260,
                          lambda=0.2,
                          limit.sd=c(2.5,3,3.5),
                          guard.band=5,
                          UCL=2,
                          correct.baseline=FALSE,
                          alarm.dim=2,
                          pre.process="diff",
                          diff.window=5)

dimnames(my.syndromic@alarms)
```

```{r pre_process}
pre_processed_data <- pre_process_glm(my.syndromic)

```


```{r shew}


my.syndromic <- shew_synd(x=my.syndromic,
                          syndromes="Musculoskeletal",
                          evaluate.window=30,
                          baseline.window=260,
                          limit.sd=c(2.5,3,3.5),
                          guard.band=5,
                          correct.baseline=FALSE,
                          alarm.dim=3,
                          UCL=2,
                          LCL=FALSE,                          
                          pre.process="glm",
                          family="poisson",
                          formula="dow+sin+cos+AR1+AR2+AR3+AR4+AR5",
                          period=260)


my.syndromic <- shew_synd(x=my.syndromic,
                           syndromes= c(1,2,4,5),
                          evaluate.window=30,
                          baseline.window=260,
                          limit.sd=c(2.5,3,3.5),
                          guard.band=5,
                          UCL=2,
                          correct.baseline=FALSE,
                          alarm.dim=3,
                          pre.process="diff",
                          diff.window=5)

dimnames(my.syndromic@alarms)
```




```{r cusum}


my.syndromic <- cusum_synd(x=my.syndromic,
                          evaluate.window=30,
                          baseline.window=260,
                          limit.sd=c(2.5,3,3.5),
                          guard.band=5,
                          correct.baseline=FALSE,
                          alarm.dim=4,
                          UCL=2,
                          LCL=FALSE,                          
                          pre.process="glm",
                          family="poisson",
                          formula="dow+sin+cos+AR1+AR2+AR3+AR4+AR5",
                          period=260)

#diff would result in negative numbers for cusum

dimnames(my.syndromic@alarms)
```


# Working "online" - receiving data in time steps and updating the system

```{r online}
data(lab.daily.update)

my.syndromic
my.syndromic <- update_syndromic(x=my.syndromic,
                                   id=SubmissionID,
                                   syndromes.var=Syndrome, 
                                   add.syndromes=TRUE,
                                   dates.var=DateofSubmission, 
                                   date.format="%d/%m/%Y", 
                                   remove.dow=c(6,0),
                                   add.to=c(2,1),
                                   replace.dates=FALSE,
                                   data=lab.daily.update)

my.syndromic
my.syndromic@observed[620:627,]
my.syndromic@dates[620:627,]
my.syndromic@alarms[620:627,,1]
my.syndromic@UCL[620:627,,1]


my.syndromic <- update_syndromic(x=my.syndromic,
                                   id=SubmissionID,
                                   syndromes.var=Syndrome, 
                                   add.syndromes=TRUE,
                                   dates.var=DateofSubmission, 
                                   date.format="%d/%m/%Y", 
                                   remove.dow=c(6,0),
                                   add.to=c(2,1),
                                   replace.dates=TRUE,
                                   data=lab.daily.update)

my.syndromic
my.syndromic@observed[620:627,]
my.syndromic@dates[620:627,]
my.syndromic@alarms[600:627,,1]
my.syndromic@UCL[600:627,,1]

```


# Prospective

repeat algorithms

# Outcomes

## Plot
```{r plot}


plot_syndromic(x=my.syndromic,
               syndromes="Musculoskeletal",
               window=365,
               baseline=TRUE,
               UCL=1,
               algorithms=NULL,
               limit=1)

plot_syndromic(x=my.syndromic,
               syndromes=c(1,4))


plot(my.syndromic)
plot(my.syndromic, syndromes=c(1,3))


```


## Alarms, email, pdf (online code)
```{r pdf}

syndromic_alarm(x=my.syndromic,
              plot.all=TRUE,
              email.alarm.to="<dorea.meyer@gmail.com>",
              email.noalarm.to="<dorea.meyer@gmail.com>")


```


## Interface
```{r syndromic.page}
getwd()
syndromic_page (x=my.syndromic,
                    week=5,
                    file.name="SpeciesX",
                    title="Lab data daily for Species X",
                    data.page=TRUE,
                    data=lab.daily,
                    date.format="%d/%m/%Y",
                    dates.var="DateofSubmission",
                    syndromes.var="Syndrome",
                     scale=9)
getwd()
```

To create a main page if multiple syndromic objectes are in place - just email the authors for a html code.


